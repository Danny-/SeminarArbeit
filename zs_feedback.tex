\subsection{Automatische Erkennung von Koreferenzen}
Da die Menge an Koreferenzen 
\[A_O=\left\{\text{'it', 'its'}\right\}\]
für Objekte nicht ausreichend ist, haben die Autoren des Papers \NaNg\cite{paper:Na} ein Verfahren entwickelt, um die Menge $A_O$ zu erweitern. Sie nennen ihren Algorithmus ``Feedback-Based Identification of Anaphoric Expressions''.\\
Man nimmt an, dass häufige auftretende Nomen mit bestimmten Artikeln in der Umgebung von Eigennamen diese referenzieren.\\

\fbox{ 
\begin{minipage}{12cm}
	\textbf{Google weiß, wo du bist}\\

	\underline{Der Datenkrake} hat ein enormes Gedächtnis – und will noch mehr erfahren. Nun sollen die Menschen Google auf dem Handy ständig bei sich tragen[\dots]\\

	Seit Beginn dieser Woche verkaufen \underline{der Internetkonzern} Google und die Mobilfunkfirma TMobile hierzulande das Handy G1, und wer es sich zulegt, trägt fortan einen cleveren kleinen Helfer mit sich herum.[\dots]\\

%	Denn anders als der heimische Laptop weiß ein Smartphone ständig, wo es ist, wo sich sein Besitzer aufhält. Das ist für die Nutzer gut, denen sich nun neue Dienste erschließen – und es würde Google viel nützen.
Denn diese Informationen hat \underline{der Internetkonzern} bisher nicht, der wie kein anderer davon lebt, zu wissen, was seine Nutzer tun. Wer sie sind. Was sie wollen. Und bald auch, wo sie sind?[\dots]\\

	Einziger Ausweg für \underline{den Internetkonzern} war, selbst ein Betriebssystem zu entwickeln, den Wettbewerb um immer leistungsfähigere Mobiltelefone zu verschärfen und nebenbei die Nutzer nicht nur zur eigenen Suche zu lenken, sondern auch zu Google Mail, Google Kalender, Google Stadtpläne, Google News, Google Earth, dem konzerneigenen Videoportal YouTube und vielem mehr.[\dots]\cite{paper:Zeit}\\
	Quelle: http://www.zeit.de/2009/07/Google
\end{minipage}
}\\
\\
Wie man an dem Beispiel schön sieht, wird Google oft mit einem bestimmten Artikel plus \underline{Internetkonzern} beschrieben.\\
Diese Nomen, die als Koreferenzen zu einem bestimmten Eigennamen auftreten können, gilt es nun zu erkennen. Dafür werden lexiko-syntaktische Muster erzeugt, um bestimmten Nomen automatisch zu extrahieren. Dann werden diejenigen Dokumente gesucht, die nach herkömmlichen Rankingmethoden am relevantesten für die Query Entity sind. Aus den relevantesten M Dokumenten werden daraufhin die bestimmten Nomen extrahiert. Zum Schluss werden die Nomen noch nach Häufigkeit sortiert. Die häufigsten M Nomen werden dann zur Menge $A_O$ hinzugefügt. Man kann zuvor noch ein Filterschritt einbauen, der diejenigen Nomen ausblendet, die in allen Dokumenten am häufigsten mit dem bestimmten Artikel auftreten. Diese sind nämlich nicht Query-spezifisch und vermutliche keine Koreferenz auf das Objekt hinter der Query Entity. 
